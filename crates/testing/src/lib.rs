//! Utilities for testing bindings generated by Wasmer Pack.
//!
//! Typical.
//!
//! ```rust
//! # use wasmer_pack_testing::TestEnvironment;
//! # fn main() -> Result<(), Box<dyn std::error::Error> {
//! let env = TestEnvironment::for_crate("./path/to/Cargo.toml")?;
//! env.python("./my_tests.py")?;
//! env.javascript("./my_test.js")?;
//! env.typescript("./my_tests.ts")?;
//! # Ok(())
//! # }
//! ```
//!
//! Under the hood, this will use `cargo wapm` to compile a Rust crate to
//! WebAssembly and turn it into a WAPM package.
//!
//! You can tell it to run test scripts written in various languages.
//!
//! The [`TestEnvironment::python()`] method will create a Virtual Environment
//! in the script's directory and install the generated Python library. The
//! provided test script will then be run in that environment using
//! [py.test][pytest].
//!
//! The [`TestEnvironment::javascript()`] and [`TestEnvironment::typescript()`]
//! methods will generate JavaScript bindings for the Rust crate and use
//! `yarn link` to add them as a dependency. From there, the test script will
//! be run using [Jest][jest].
//!
//! [pytest]: https://docs.pytest.org/
//! [jest]: https://jestjs.io/

use std::{
    fmt::{self, Display, Formatter},
    io::ErrorKind,
    path::{Path, PathBuf},
    process::{Command, Output, Stdio},
};

use tempfile::TempDir;

#[derive(Debug)]
pub struct TestEnvironment {
    temp_dir: TempDir,
    wapm_dir: PathBuf,
}

impl TestEnvironment {
    pub fn for_crate(manifest_path: impl AsRef<Path>) -> Result<Self, LoadError> {
        let temp_dir = TempDir::new().map_err(LoadError::TempDir)?;
        let manifest_path = manifest_path.as_ref();

        let wapm_dir = compile_rust_to_wapm_package(manifest_path, temp_dir.path())?;

        Ok(TestEnvironment { temp_dir, wapm_dir })
    }

    pub fn python(&self, _script_path: impl AsRef<Path>) -> Result<(), TestFailure> {
        todo!();
    }

    pub fn javascript(&self, _script_path: impl AsRef<Path>) -> Result<(), TestFailure> {
        todo!();
    }

    pub fn typescript(&self, _script_path: impl AsRef<Path>) -> Result<(), TestFailure> {
        todo!();
    }
}

#[derive(Debug)]
pub enum TestFailure {}

fn compile_rust_to_wapm_package(
    manifest_path: &Path,
    target_dir: &Path,
) -> Result<PathBuf, LoadError> {
    let mut cmd = Command::new("cargo");
    cmd.arg("wapm")
        .arg("--dry-run")
        .arg("--manifest-path")
        .arg(manifest_path);

    let command = format!("{cmd:?}");

    let Output {
        status,
        stdout,
        stderr,
    } = cmd
        .env("TARGET_DIR", target_dir)
        .stderr(Stdio::piped())
        .stdout(Stdio::piped())
        .output()
        .map_err(LoadError::SpawnFailed)?;

    if !status.success() {
        return Err(LoadError::BindingsGenerationFailed {
            command,
            stdout: String::from_utf8_lossy(&stdout).into_owned(),
            stderr: String::from_utf8_lossy(&stderr).into_owned(),
            exit_code: status.code(),
        });
    }

    let wapm_dir = target_dir.join("wapm");

    let generated_package_dir =
        first_dir_in_folder(&wapm_dir).map_err(|e| LoadError::UnableToLocateBindings {
            dir: wapm_dir,
            error: e,
        })?;

    Ok(generated_package_dir)
}

fn first_dir_in_folder(dir: &Path) -> Result<PathBuf, std::io::Error> {
    let mut entries = dir.read_dir()?;

    let first_item = match entries.next() {
        Some(Ok(entry)) => entry.path(),
        Some(Err(e)) => return Err(e),
        None => todo!(),
    };

    if !first_item.is_dir() {
        return Err(std::io::Error::new(
            ErrorKind::Other,
            format!("Expected \"{}\" to be a directory", first_item.display(),),
        ));
    }

    Ok(first_item)
}

#[derive(Debug)]
pub enum LoadError {
    ManifestNotFound {
        path: PathBuf,
    },
    TempDir(std::io::Error),
    SpawnFailed(std::io::Error),
    BindingsGenerationFailed {
        command: String,
        stdout: String,
        stderr: String,
        exit_code: Option<i32>,
    },
    UnableToLocateBindings {
        dir: PathBuf,
        error: std::io::Error,
    },
}

impl std::error::Error for LoadError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            LoadError::TempDir(e)
            | LoadError::SpawnFailed(e)
            | LoadError::UnableToLocateBindings { error: e, .. } => Some(e),
            LoadError::ManifestNotFound { .. } | LoadError::BindingsGenerationFailed { .. } => None,
        }
    }
}

impl Display for LoadError {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        match self {
            LoadError::ManifestNotFound { path } => {
                write!(f, "\"{}\" doesn't exist", path.display())
            }
            LoadError::TempDir(_) => write!(f, "Unable to create a temporary directory"),
            LoadError::SpawnFailed(_) => {
                write!(f, "Unable to start \"cargo wapm\". Is it installed?")
            }
            LoadError::BindingsGenerationFailed {
                command,
                stdout,
                stderr,
                exit_code,
            } => {
                write!(f, "{command} failed")?;
                if let Some(exit_code) = exit_code {
                    write!(f, " with exit code {exit_code}")?;
                }
                write!(f, ".")?;

                if !stdout.trim().is_empty() {
                    writeln!(f)?;
                    writeln!(f, "Stdout: {stdout}")?;
                }
                if !stderr.trim().is_empty() {
                    writeln!(f)?;
                    writeln!(f, "Stderr: {stderr}")?;
                }

                Ok(())
            }
            LoadError::UnableToLocateBindings { dir, .. } => write!(
                f,
                "Unable to locate the generated bindings in \"{}\"",
                dir.display()
            ),
        }
    }
}
